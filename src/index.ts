#!/usr/bin/env node

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { WebClient } from "@slack/web-api";
import { z } from "zod";
import https from "https";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { exec } from "child_process";

// Get directory of this script
const __dirname = path.dirname(fileURLToPath(import.meta.url));
const PROJECT_ROOT = path.join(__dirname, "..");

// Configuration
const SLACK_CLIENT_ID = process.env.SLACK_CLIENT_ID;
const SLACK_CLIENT_SECRET = process.env.SLACK_CLIENT_SECRET;
const TOKEN_FILE = process.env.SLACK_TOKEN_FILE || path.join(PROJECT_ROOT, ".slack-token.json");
const OAUTH_PORT = 8435;

// SSL certificate paths (generated by mkcert)
const CERT_PATH = path.join(PROJECT_ROOT, "localhost+1.pem");
const KEY_PATH = path.join(PROJECT_ROOT, "localhost+1-key.pem");

// Slack OAuth scopes for full read/write access
const SLACK_SCOPES = [
  "channels:read",
  "groups:read",
  "channels:history",
  "groups:history",
  "im:read",
  "im:history",
  "mpim:read",
  "mpim:history",
  "chat:write",
  "users:read",
  "reactions:read",
  "reactions:write",
  "files:read",
  "files:write",
  "search:read",
].join(",");

// Token data interface
interface TokenData {
  slackToken: string;
  userId: string;
  teamId: string;
  teamName: string;
  expiresAt?: number;
}

// Load saved token from file
function loadToken(): TokenData | null {
  try {
    if (fs.existsSync(TOKEN_FILE)) {
      const data = JSON.parse(fs.readFileSync(TOKEN_FILE, "utf-8"));
      // Check if token has expiration and is expired
      if (data.expiresAt && Date.now() > data.expiresAt) {
        console.error("Saved token has expired, need to re-authenticate");
        return null;
      }
      return data;
    }
  } catch (error) {
    console.error("Error loading token:", error);
  }
  return null;
}

// Save token to file
function saveToken(tokenData: TokenData): void {
  try {
    fs.writeFileSync(TOKEN_FILE, JSON.stringify(tokenData, null, 2), { mode: 0o600 });
    console.error(`Token saved to ${TOKEN_FILE}`);
  } catch (error) {
    console.error("Error saving token:", error);
  }
}

// Open URL in default browser
function openBrowser(url: string): void {
  const platform = process.platform;
  let command: string;

  if (platform === "win32") {
    command = `start "" "${url}"`;
  } else if (platform === "darwin") {
    command = `open "${url}"`;
  } else {
    command = `xdg-open "${url}"`;
  }

  exec(command, (error) => {
    if (error) {
      console.error("Could not open browser. Please manually visit:", url);
    }
  });
}

// Perform OAuth flow
async function performOAuth(): Promise<TokenData> {
  if (!SLACK_CLIENT_ID || !SLACK_CLIENT_SECRET) {
    throw new Error("SLACK_CLIENT_ID and SLACK_CLIENT_SECRET environment variables are required");
  }

  // Check for SSL certificates
  if (!fs.existsSync(CERT_PATH) || !fs.existsSync(KEY_PATH)) {
    throw new Error(
      `SSL certificates not found. Please run:\n` +
      `  cd "${PROJECT_ROOT}"\n` +
      `  mkcert localhost 127.0.0.1\n\n` +
      `This will create the required certificate files.`
    );
  }

  const sslOptions = {
    cert: fs.readFileSync(CERT_PATH),
    key: fs.readFileSync(KEY_PATH),
  };

  return new Promise((resolve, reject) => {
    const server = https.createServer(sslOptions, async (req, res) => {
      const url = new URL(req.url!, `https://localhost:${OAUTH_PORT}`);

      if (url.pathname === "/callback") {
        const code = url.searchParams.get("code");
        const error = url.searchParams.get("error");

        if (error) {
          res.writeHead(400, { "Content-Type": "text/html" });
          res.end(`<h1>Authorization Failed</h1><p>${error}</p><p>You can close this window.</p>`);
          server.close();
          reject(new Error(`OAuth error: ${error}`));
          return;
        }

        if (code) {
          try {
            // Exchange code for token
            const slack = new WebClient();
            const result = await slack.oauth.v2.access({
              client_id: SLACK_CLIENT_ID!,
              client_secret: SLACK_CLIENT_SECRET!,
              code,
              redirect_uri: `https://localhost:${OAUTH_PORT}/callback`,
            });

            if (!result.ok || !result.authed_user?.access_token) {
              throw new Error(`Slack OAuth failed: ${result.error}`);
            }

            const tokenData: TokenData = {
              slackToken: result.authed_user.access_token,
              userId: result.authed_user.id!,
              teamId: result.team?.id || "unknown",
              teamName: result.team?.name || "Unknown Workspace",
            };

            // Save token
            saveToken(tokenData);

            res.writeHead(200, { "Content-Type": "text/html" });
            res.end(`
              <h1>Authorization Successful!</h1>
              <p>Authenticated as user in <strong>${tokenData.teamName}</strong></p>
              <p>You can close this window and return to Claude Desktop.</p>
              <script>setTimeout(() => window.close(), 3000);</script>
            `);

            server.close();
            resolve(tokenData);
          } catch (err) {
            res.writeHead(500, { "Content-Type": "text/html" });
            res.end(`<h1>Error</h1><p>${err}</p>`);
            server.close();
            reject(err);
          }
        }
      } else {
        res.writeHead(404);
        res.end("Not found");
      }
    });

    server.listen(OAUTH_PORT, () => {
      const authUrl = new URL("https://slack.com/oauth/v2/authorize");
      authUrl.searchParams.set("client_id", SLACK_CLIENT_ID!);
      authUrl.searchParams.set("user_scope", SLACK_SCOPES);
      authUrl.searchParams.set("redirect_uri", `https://localhost:${OAUTH_PORT}/callback`);

      console.error("\n=== Slack Authorization Required ===");
      console.error("Opening browser for Slack authorization...");
      console.error("If browser doesn't open, visit:", authUrl.toString());
      console.error("=====================================\n");

      openBrowser(authUrl.toString());
    });

    // Timeout after 5 minutes
    setTimeout(() => {
      server.close();
      reject(new Error("OAuth timeout - no authorization received within 5 minutes"));
    }, 5 * 60 * 1000);
  });
}

// Get or create Slack client
async function getSlackClient(): Promise<WebClient> {
  // Try to load existing token
  let tokenData = loadToken();

  // If no token, perform OAuth
  if (!tokenData) {
    console.error("No saved token found, initiating OAuth flow...");
    tokenData = await performOAuth();
  }

  return new WebClient(tokenData.slackToken);
}

// Create MCP server with Slack tools
function createMcpServer(slack: WebClient): McpServer {
  const server = new McpServer({
    name: "slack-mcp",
    version: "2.0.0",
  });

  // Tool: List channels
  server.tool(
    "list_channels",
    "List all Slack channels the user has access to",
    {
      limit: z.number().min(1).max(200).optional().describe("Number of channels to return (default: 100)"),
      types: z.string().optional().describe("Channel types: public_channel, private_channel, mpim, im (comma-separated, default: public_channel,private_channel)"),
    },
    async ({ limit = 100, types = "public_channel,private_channel" }) => {
      try {
        const result = await slack.conversations.list({
          limit,
          exclude_archived: true,
          types: types as any,
        });

        if (!result.ok || !result.channels) {
          return {
            content: [{ type: "text", text: `Slack API error: ${result.error || "Unknown error"}` }],
            isError: true,
          };
        }

        const channels = result.channels.map((ch) => ({
          id: ch.id,
          name: ch.name,
          topic: ch.topic?.value || "",
          purpose: ch.purpose?.value || "",
          is_private: ch.is_private,
          is_im: ch.is_im,
          is_mpim: ch.is_mpim,
          num_members: ch.num_members,
        }));

        return {
          content: [{ type: "text", text: JSON.stringify(channels, null, 2) }],
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: `Error listing channels: ${error instanceof Error ? error.message : String(error)}` }],
          isError: true,
        };
      }
    }
  );

  // Tool: Get channel messages
  server.tool(
    "get_channel_messages",
    "Fetch messages from a Slack channel",
    {
      channel_id: z.string().describe("The Slack channel ID (e.g., C1234567890)"),
      limit: z.number().min(1).max(100).optional().describe("Number of messages to fetch (default: 50)"),
      fetch_all: z.boolean().optional().describe("Fetch all messages using pagination (default: false)"),
    },
    async ({ channel_id, limit = 50, fetch_all = false }) => {
      try {
        const allMessages: any[] = [];
        let cursor: string | undefined = undefined;
        let hasMore = true;

        while (hasMore) {
          const result = await slack.conversations.history({
            channel: channel_id,
            limit: fetch_all ? 100 : limit,
            cursor,
          });

          if (!result.ok || !result.messages) {
            return {
              content: [{ type: "text", text: `Slack API error: ${result.error || "Unknown error"}` }],
              isError: true,
            };
          }

          const messages = result.messages.map((msg) => ({
            ts: msg.ts,
            user: msg.user,
            text: msg.text,
            thread_ts: msg.thread_ts,
            reply_count: msg.reply_count,
            timestamp: new Date(parseFloat(msg.ts!) * 1000).toISOString(),
          }));

          allMessages.push(...messages);

          if (fetch_all && result.response_metadata?.next_cursor) {
            cursor = result.response_metadata.next_cursor;
          } else {
            hasMore = false;
          }

          if (!fetch_all) break;
        }

        return {
          content: [{ type: "text", text: JSON.stringify(allMessages, null, 2) }],
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: `Error fetching messages: ${error instanceof Error ? error.message : String(error)}` }],
          isError: true,
        };
      }
    }
  );

  // Tool: Post message
  server.tool(
    "post_message",
    "Post a message to a Slack channel",
    {
      channel_id: z.string().describe("The Slack channel ID to post to"),
      text: z.string().describe("The message text to post"),
      thread_ts: z.string().optional().describe("Thread timestamp to reply to (for threaded replies)"),
    },
    async ({ channel_id, text, thread_ts }) => {
      try {
        const result = await slack.chat.postMessage({
          channel: channel_id,
          text,
          thread_ts,
        });

        if (!result.ok) {
          return {
            content: [{ type: "text", text: `Slack API error: ${result.error || "Unknown error"}` }],
            isError: true,
          };
        }

        return {
          content: [{ type: "text", text: JSON.stringify({ success: true, ts: result.ts, channel: result.channel }, null, 2) }],
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: `Error posting message: ${error instanceof Error ? error.message : String(error)}` }],
          isError: true,
        };
      }
    }
  );

  // Tool: Add reaction
  server.tool(
    "add_reaction",
    "Add an emoji reaction to a message",
    {
      channel_id: z.string().describe("The channel containing the message"),
      timestamp: z.string().describe("The timestamp of the message to react to"),
      emoji: z.string().describe("The emoji name (without colons, e.g., 'thumbsup')"),
    },
    async ({ channel_id, timestamp, emoji }) => {
      try {
        const result = await slack.reactions.add({
          channel: channel_id,
          timestamp,
          name: emoji,
        });

        if (!result.ok) {
          return {
            content: [{ type: "text", text: `Slack API error: ${result.error || "Unknown error"}` }],
            isError: true,
          };
        }

        return {
          content: [{ type: "text", text: JSON.stringify({ success: true }, null, 2) }],
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: `Error adding reaction: ${error instanceof Error ? error.message : String(error)}` }],
          isError: true,
        };
      }
    }
  );

  // Tool: Get user info
  server.tool(
    "get_user_info",
    "Get information about a Slack user",
    {
      user_id: z.string().describe("The Slack user ID (e.g., U1234567890)"),
    },
    async ({ user_id }) => {
      try {
        const result = await slack.users.info({ user: user_id });

        if (!result.ok || !result.user) {
          return {
            content: [{ type: "text", text: `Slack API error: ${result.error || "Unknown error"}` }],
            isError: true,
          };
        }

        const user = {
          id: result.user.id,
          name: result.user.name,
          real_name: result.user.real_name,
          display_name: result.user.profile?.display_name,
          email: result.user.profile?.email,
          title: result.user.profile?.title,
          is_admin: result.user.is_admin,
          is_bot: result.user.is_bot,
          timezone: result.user.tz,
        };

        return {
          content: [{ type: "text", text: JSON.stringify(user, null, 2) }],
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: `Error getting user info: ${error instanceof Error ? error.message : String(error)}` }],
          isError: true,
        };
      }
    }
  );

  // Tool: List users
  server.tool(
    "list_users",
    "List all users in the Slack workspace",
    {
      limit: z.number().min(1).max(200).optional().describe("Number of users to return (default: 100)"),
    },
    async ({ limit = 100 }) => {
      try {
        const result = await slack.users.list({ limit });

        if (!result.ok || !result.members) {
          return {
            content: [{ type: "text", text: `Slack API error: ${result.error || "Unknown error"}` }],
            isError: true,
          };
        }

        const users = result.members
          .filter((u) => !u.deleted && !u.is_bot)
          .map((u) => ({
            id: u.id,
            name: u.name,
            real_name: u.real_name,
            display_name: u.profile?.display_name,
            email: u.profile?.email,
            is_admin: u.is_admin,
          }));

        return {
          content: [{ type: "text", text: JSON.stringify(users, null, 2) }],
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: `Error listing users: ${error instanceof Error ? error.message : String(error)}` }],
          isError: true,
        };
      }
    }
  );

  // Tool: Get thread replies
  server.tool(
    "get_thread_replies",
    "Get all replies in a message thread",
    {
      channel_id: z.string().describe("The channel containing the thread"),
      thread_ts: z.string().describe("The timestamp of the parent message"),
    },
    async ({ channel_id, thread_ts }) => {
      try {
        const result = await slack.conversations.replies({
          channel: channel_id,
          ts: thread_ts,
        });

        if (!result.ok || !result.messages) {
          return {
            content: [{ type: "text", text: `Slack API error: ${result.error || "Unknown error"}` }],
            isError: true,
          };
        }

        const messages = result.messages.map((msg) => ({
          ts: msg.ts,
          user: msg.user,
          text: msg.text,
          timestamp: new Date(parseFloat(msg.ts!) * 1000).toISOString(),
        }));

        return {
          content: [{ type: "text", text: JSON.stringify(messages, null, 2) }],
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: `Error getting thread replies: ${error instanceof Error ? error.message : String(error)}` }],
          isError: true,
        };
      }
    }
  );

  // Tool: Search messages
  server.tool(
    "search_messages",
    "Search for messages in Slack",
    {
      query: z.string().describe("The search query"),
      count: z.number().min(1).max(100).optional().describe("Number of results to return (default: 20)"),
    },
    async ({ query, count = 20 }) => {
      try {
        const result = await slack.search.messages({
          query,
          count,
        });

        if (!result.ok || !result.messages) {
          return {
            content: [{ type: "text", text: `Slack API error: ${result.error || "Unknown error"}` }],
            isError: true,
          };
        }

        const messages = result.messages.matches?.map((match) => ({
          channel: match.channel?.name,
          channel_id: match.channel?.id,
          user: match.user,
          text: match.text,
          ts: match.ts,
          permalink: match.permalink,
        })) || [];

        return {
          content: [{ type: "text", text: JSON.stringify(messages, null, 2) }],
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: `Error searching messages: ${error instanceof Error ? error.message : String(error)}` }],
          isError: true,
        };
      }
    }
  );

  // Tool: List files
  server.tool(
    "list_files",
    "List files shared in channels and conversations",
    {
      channel_id: z.string().optional().describe("Filter to files in a specific channel"),
      user_id: z.string().optional().describe("Filter to files uploaded by a specific user"),
      types: z.string().optional().describe("Filter by file types (comma-separated): spaces, snippets, images, gdocs, zips, pdfs, all"),
      count: z.number().min(1).max(100).optional().describe("Number of files to return (default: 20)"),
    },
    async ({ channel_id, user_id, types, count = 20 }) => {
      try {
        const result = await slack.files.list({
          channel: channel_id,
          user: user_id,
          types,
          count,
        });

        if (!result.ok || !result.files) {
          return {
            content: [{ type: "text", text: `Slack API error: ${result.error || "Unknown error"}` }],
            isError: true,
          };
        }

        const files = result.files.map((file) => ({
          id: file.id,
          name: file.name,
          title: file.title,
          filetype: file.filetype,
          size: file.size,
          user: file.user,
          created: file.created ? new Date(file.created * 1000).toISOString() : null,
          url_private: file.url_private,
          permalink: file.permalink,
          channels: file.channels,
        }));

        return {
          content: [{ type: "text", text: JSON.stringify(files, null, 2) }],
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: `Error listing files: ${error instanceof Error ? error.message : String(error)}` }],
          isError: true,
        };
      }
    }
  );

  // Tool: Get file info
  server.tool(
    "get_file_info",
    "Get detailed information about a specific file",
    {
      file_id: z.string().describe("The file ID (e.g., F1234567890)"),
    },
    async ({ file_id }) => {
      try {
        const result = await slack.files.info({ file: file_id });

        if (!result.ok || !result.file) {
          return {
            content: [{ type: "text", text: `Slack API error: ${result.error || "Unknown error"}` }],
            isError: true,
          };
        }

        const file = {
          id: result.file.id,
          name: result.file.name,
          title: result.file.title,
          filetype: result.file.filetype,
          mimetype: result.file.mimetype,
          size: result.file.size,
          user: result.file.user,
          created: result.file.created ? new Date(result.file.created * 1000).toISOString() : null,
          url_private: result.file.url_private,
          url_private_download: result.file.url_private_download,
          permalink: result.file.permalink,
          permalink_public: result.file.permalink_public,
          channels: result.file.channels,
          groups: result.file.groups,
          ims: result.file.ims,
          comments_count: result.file.comments_count,
          shares: result.file.shares,
        };

        return {
          content: [{ type: "text", text: JSON.stringify(file, null, 2) }],
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: `Error getting file info: ${error instanceof Error ? error.message : String(error)}` }],
          isError: true,
        };
      }
    }
  );

  // Tool: Summarize channel
  server.tool(
    "summarize_channel",
    "Fetch all messages from a channel for summarization",
    {
      channel_name: z.string().describe("The Slack channel name (with or without #)"),
    },
    async ({ channel_name }) => {
      try {
        const cleanChannelName = channel_name.replace(/^#/, "");

        const channelsResult = await slack.conversations.list({
          limit: 1000,
          exclude_archived: true,
          types: "public_channel,private_channel",
        });

        if (!channelsResult.ok || !channelsResult.channels) {
          return {
            content: [{ type: "text", text: `Slack API error: ${channelsResult.error || "Unknown error"}` }],
            isError: true,
          };
        }

        const channel = channelsResult.channels.find(
          (ch) => ch.name === cleanChannelName || ch.name === channel_name
        );

        if (!channel || !channel.id) {
          return {
            content: [{ type: "text", text: `Channel "${channel_name}" not found.` }],
            isError: true,
          };
        }

        const allMessages: any[] = [];
        let cursor: string | undefined = undefined;
        let hasMore = true;

        while (hasMore) {
          const result = await slack.conversations.history({
            channel: channel.id,
            limit: 100,
            cursor,
          });

          if (!result.ok || !result.messages) {
            return {
              content: [{ type: "text", text: `Slack API error: ${result.error || "Unknown error"}` }],
              isError: true,
            };
          }

          allMessages.push(...result.messages);

          if (result.response_metadata?.next_cursor) {
            cursor = result.response_metadata.next_cursor;
          } else {
            hasMore = false;
          }
        }

        allMessages.sort((a, b) => parseFloat(a.ts) - parseFloat(b.ts));

        const formattedMessages = allMessages
          .filter((msg) => msg.text && !msg.subtype)
          .map((msg) => ({
            timestamp: new Date(parseFloat(msg.ts) * 1000).toISOString(),
            user: msg.user || "unknown",
            text: msg.text,
            is_thread: !!msg.thread_ts,
            reply_count: msg.reply_count || 0,
          }));

        const summary = {
          channel_name: channel.name || channel_name,
          channel_id: channel.id,
          total_messages: formattedMessages.length,
          date_range: {
            oldest: formattedMessages[0]?.timestamp || "N/A",
            newest: formattedMessages[formattedMessages.length - 1]?.timestamp || "N/A",
          },
          messages: formattedMessages,
        };

        return {
          content: [{ type: "text", text: JSON.stringify(summary, null, 2) }],
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: `Error summarizing channel: ${error instanceof Error ? error.message : String(error)}` }],
          isError: true,
        };
      }
    }
  );

  // Tool: Re-authenticate (force new OAuth flow)
  server.tool(
    "slack_reauth",
    "Force re-authentication with Slack (use if token expired or you want to switch accounts)",
    {},
    async () => {
      try {
        // Delete existing token
        if (fs.existsSync(TOKEN_FILE)) {
          fs.unlinkSync(TOKEN_FILE);
        }

        // Perform new OAuth
        const tokenData = await performOAuth();

        // Update the slack client - this is tricky with closures
        // For now, just tell the user to restart
        return {
          content: [{ type: "text", text: `Re-authenticated successfully as user in ${tokenData.teamName}. Please restart the MCP server for changes to take effect.` }],
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: `Error during re-authentication: ${error instanceof Error ? error.message : String(error)}` }],
          isError: true,
        };
      }
    }
  );

  return server;
}

// Main entry point
async function main() {
  try {
    // Get Slack client (will trigger OAuth if needed)
    const slack = await getSlackClient();

    // Create and start MCP server
    const server = createMcpServer(slack);
    const transport = new StdioServerTransport();

    await server.connect(transport);
    console.error("Slack MCP server running on stdio");
  } catch (error) {
    console.error("Failed to start server:", error);
    process.exit(1);
  }
}

main();
